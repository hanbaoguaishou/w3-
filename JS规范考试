判断
1.在任何打开花括号 { 之前增加空格，包括在作为函数的第一个参数或数组中的第一个元素时，对象之前也要加空格
错误

单选
1.使用ES6编码的Web前端项目中，使用模块化机制正确且符合编程规范的是（）
√A.import foo from './foo';
B.import foo from './foo'; import React from 'react';
C.const foo = require('./foo');
D.import bar from './bar.jsx';

2.以下代码的输出是（） const myHash = []; myHash['key1'] = 'val1'; myHash['key2'] = 'val2'; myHash[0] = '222'; for (const key in myHash) { console.log(key); } console.log(myHash.length);
A.key1 key2 0 3
B.key1 key2 0 1
√C.0 key1 key2 1
D.0 key1 key2 3

3.以下说法错误的是（）
A.块语句的最大可嵌套深度不要超过5层
√B.方法长度不超过50行
C.控制文件的长度，最好不要超过2000行
D.每行代码应该少于120个字符

4.下面代码输出是什么（） let str = "Hi"; str[0] = "h"; str[1] = "ello"; str = str[0] + str[1]; console.log(str);
A.error
B.hello
C.hi
D.Hi

5.对象字面量属性超过()个, 需要都换行
A.7
B.6
C.5
√D.4

6.关于初始化变量，不正确是（）
A.用{a:"", b:1}初始化
B.用null初始化
√C.用undefined初始化

7.给定以下URL，下列表达式为 true 的是（） http://www.huawei.com:8001/test#test?key=value
A.location.protocol === 'http://'
B.location.pathname === '/test'
C.location.host === 'www.huawei.com'
√D.location.search === '?key=value'

8.链式调用对象方法时，一行最多调用()次，否则需要换行
√A.4
B.3
C.2
D.5

9.以下程序执行后在控制台输出的结果是（） const name = "cat"; switch (name) { case "cat": console.log( "cat"); case "dog": console.log( "dog"); break; case "fish": console.log( "fish"); break; default: console.log( "default"); }
A.cat
B.dog fish
√C.cat dog
D.default

10.方法的参数个数不宜超过()个
A.6
B.4
C.3
√D.5


多选
1.当插入不可信数据到（）时，需要先转义。
A.执行环境的CSS属性上下文
√B.执行环境上下文的HTML当中
C.事件处理程序和执行环境中javaScript上下文中
√D.到执行环境中的HTML 属性上下文

2.关于 CSS 盒模型，说法正确的是（）
√A.在 IE 模型中，如果你给盒设置width和height，实际设置的是显示区域content大小，不包含margin,border,padding
B.CSS 盒模型分为标准模型和IE模型
√C.标准模型可以通过设置box-sizing: border-box转换为IE模型
√D.模型定义了盒的每个部分 margin, border, padding, 和 content

3.数组类型的使用过程，正确的有：()
√A.向数组添加元素时使用 Arrary#push 替代直接下标赋值
√B.不要在forEach循环里进行元素的 remove/add 操作
C.数组遍历优先使用for

4.以下类型转换写法正确的是（）
√A.const num = Number(foo);
√B.const isFoo = Boolean(foo);
√C.foo += '';
√D.const isFoo = !!foo;
√E.const num = +foo;

5.考虑安全编码的攻击者思维时，哪种是正确的说法：()
√A.攻击者会破坏程序的运行环境，因此即使对于本地的操作系统环境变量，配置文件数据，也需要严格校验。
B.攻击者难以直接接触磁盘数据，因此本地数据是完全可信的。
√C.攻击者时刻都试图监听网络中的敏感信息，因此口令等敏感信息必须加密传输，不要使用不安全的明文协议如ftp, telnet等。
√D.攻击者总是可以篡改网络上的报文, 因此不要假定报文来自可信设备，就忽略输入校验。

6.以下符合规范的写法的是（）
√A.const good = { foo: 3, bar: 4, 'data-blah': 5, };
√B.const obj = { set name(value) { this.nameVal = value; } }
√C.const original = { age: 1, bee: 2 }; const copy = { ...original, cat: 3 };
√D.const hasBarProperty = foo.hasOwnProperty('bar');

7.下列关于空格的使用中，正确的有：()
√A.数组的括号内不要有空格
√B.单行的{}内侧要有空格
√C.关键字周围空格的一致性
√D.禁止出现多个连续空格

8.以下程序执行会导致什么结果（） // 'use strict' setTimeout(function() { this.name = 'hello' });
√A.正常执行不会报错
B.非严格模式下会报错，找不到this
√C.严格模式下回报错，找不到this
D.无论严格模式还是非严格模式，浏览器setTimeOut内的this永远指向window,执行结果是在window上挂载了一 个属性 name=hello 造成内存泄漏

9.禁止使用（）函数来处理来自外部的不可信数据。
√A.setInterval()
√B.setTimeout()
C.{{expression}}
√D.eval()

10.安全敏感对象不应被序列化，在验证反序列化对象的数据时，应过滤哪些特殊字符？
√A.单引号
√B./ 斜杠
√C.< 角括弧
√D.双引号
√E.& 与字符

11.以下不符合规范写法的是（）
√A.class Base { static foo() {} } class Sub extends Base {} Sub.foo();
B.class ClassA extends ClassB { constructor() { this.age = 0; super(); } }
C.function Queue(contents = []) { this._queue = [...contents]; } Queue.prototype.pop = function() { const value = this._queue[0]; this._queue.splice(0, 1); return value; }
√D.class PeekableQueue extends Queue { peek() { return this._queue[0]; } }

12.下列关于函数的参数的描述中，正确的有：()
√A.不要使用 arguments，可以选择 rest 语法替代
√B.总是将默认参数放在最后
√C.给函数的参数指定默认值
D.不要把方法的入参当作工作变量/临时变量

13.关于DOM操作，下列说法正确的是:()
√A.在满足业务特性需求的情况下，减少DOM对象的动态创建和删除
√B.在普通的HTML页面上，不建议在标签上直接嵌入JavaScript事件回调代码
√C.闭包容易造成JavaScript对象和DOM的循环引用，从而造成内存泄露，使用时要慎重
D.当需要直接操作DOM时，使用元素选择器比使用ID选择器效率更高
